\documentclass[a4paper,11pt]{article}
\usepackage[utf8]{inputenc}

\usepackage{times}             % Police de caractères
\usepackage[french]{babel}
\usepackage[top=1.5cm, bottom=1.5cm, left=1.5cm, right=1.5cm]{geometry}

\usepackage{tikz}
\usepackage{graphicx}


\date{\today} 
\title{Projet C - Le Voyageur de commerce}
\author{Alice PELLET -- MARY \& Pierre MACHEREL}

\tikzstyle{vertex}=[circle,fill=black!25,minimum size=20pt,inner sep=0pt]
\tikzstyle{selected vertex} = [vertex, fill=red!24]
\tikzstyle{edge} = [draw,thick,-]
\tikzstyle{weight} = [font=\small]
\tikzstyle{selected edge} = [draw,line width=5pt,-,red!50]
\tikzstyle{cycle} = [draw,line width=5pt,-,black!20]
\tikzstyle{cheminarbre} = [draw,thick,blue]
\tikzstyle{ignored edge} = [draw,line width=5pt,-,black!20]

\begin{document}

\maketitle
\tableofcontents

\section*{Introduction} %Alice

L'objectif de ce projet en binôme de 6 semaines était d'écrire un programme permettant d'approcher le problème du voyageur de commerce. Pour ce faire, il nous avons choisi et implementé différentes sutrcture de données permétant d'enregistrer un grand nombre de données, ou bien de représenter un graphe.\\
Le problème du voyageur de commerce se pose de la façon suivante : on dispose d'une liste de ville qu'un voyageur de commerce voudrait parcourir en minimisant la distance du chemin. Il essaye donc de trouver un chemin minimal passant par toutes les villes et qui revient à son point de départ. Ce problème est un problème fréquent dans de nombreux domaines de l'informatique \textbf{{\Large (COMME ?)}} mais il est NP-Complet : on ne connait pas d'algorithme permettant de le résoudre rapidement (en temps polynomial).\\
Nous avons implémenté un programme basé sur l’algorithme de Prim. Cet algorithme ne donne pas le résultat optimal du voyageur de commerce mais a l'avantage d'avoir une complexité polynomiale.\\

\section{Structures de données}
Notre programme fait appel à quatre structures de données principales : \textsf{Ville}, \textsf{element\_liste*}, \textsf{Matrice} et \textsf{Tas} qui permetent réspectivement de représenté une ville avec ses coordonées, un arbre, un graph complet et un ensemble d'arete.
Chaque structure présente des avantages (accées à une information en temps constant, recherche d'un minimum dans un ensemble, etc) et inconveignant (dificulté d'insertions, place en mémoire ...).

\textcolor{red}{primitive d'acces pour structure de donnée : avantage : facilité de modification de la structure}

\subsection{Villes}

Dans l'algorithme, les villes sont représentée par des entiers. On a donc créé un type \textsf{Ville} dans les fichier \emph{structure\_ville}, qui contient le nom de la ville et ses coordonnées. L'ensemble des villes du problème est enregistré dans un tableau de Villes. Cela permet d'associer à chaque ville sa position dans le tableau. Ce tableau est lui même stocké dans la structure \textsf{Matrice} que nous décrire plus tard.\\
La structure Ville apparait également dans toutes les fonctions liées à la lecture/écriture des villes dans un fichier, ainsi que dans l'interface utilisateur.\\

\subsection{Arbre couvrant}

L'algorithme que nous avons implémenté nécessite la création d'un arbre couvrant minimal. On le parcourt ensuite pour trouver l'ordre des villes dans le chemin.\\
{\Large Liste chainée}\\
Implémenté dans les fichier \emph{structure\_arbre\_couvrant}
\textsf{element\_liste*}
précisé que l'ajout d'arete dans la structure est aisé.
Pour stocker l'arbre couvrant, on a créé un tableau avec autant de cases qu'il y a de villes, puis dans chaque case i du tableau on stocke la liste des voisins du sommet i dans l'arbre. Comme l'arbre doit être couvrant, tous les sommets apparaissent au moins une fois à l'extrémité d'une arête, donc on ne gâche pas de place en stockant l'arbre dans un tableau.\\
Cet arbre couvrant est également stocké dans la structure Matrice.\\

\subsection{Matrice} %Alice
Décrite dans les fichier \emph{structure\_matrice}, la structure \textsf{Matrice} contient toutes les informations nécessaires à l'algorithme TSP qui résout le problème du voyageur de commerce :
\begin{itemize}
\renewcommand{\FrenchLabelItem}{\textbullet}
\item Un entier \texttt{nb\_villes} représentant le nombre de villes à parcourir.
\item Une matrice d'adjacence \texttt{graph} qui contient le poids de chaque arête. Les cases (i,j) et (j,i) de la matrice contiennent le poids de l'arête allant du sommet i au sommet j. Une matrice d'adjacence est très volumineuse, mais elle permet d'accédé en temps constant au poids d'une arête.
\item Un tableau d'entiers \texttt{marque} qui sert lors de l'algorithme. Chaque case du tableau représente une ville, qui est marquée si la case contient un 1 et non marquée si elle contient un 0.
\item Un tableau de \textsf{Ville} \texttt{liste\_name} qui permet la conversion entier-ville. Chaque case i du tableau contient la ville associée à l'entier i.
\item Un vecteur de liste de sommet \texttt{arbre\_couvrant}qui permet de stocker l'arbre couvrant.
\item Une liste de sommets \texttt{cycle} qui contient le cycle calculé par notre programme \textcolor{red}{ ordonnées par le parcourt l'arbre couvrant (chaque sommet n'étant écrit qu'une seule fois). $\rightarrow$ à précisé dans la fonction parcourt arbre}
\item Les coordonnées maximales des villes stockées dans le tableau \texttt{liste\_name} (\texttt{xmin, xmax, ymin, ymax}) nécessaire pour l'affichage graphique.
\end{itemize}

La structure Matrice regroupe l'ensemble des données nécessaire à la résolution du problème du voyageur de commerce et a l’affichage du résultat.
Elle camoufle un pointeur vers une autre structure encapsulé. Cela évite la recopis lorsque elle est donnée en argument dans une fonction. Elle apparait dans les fonctions Prim, TSP ainsi que dans les fonctions auxiliaires à ces 2 fonctions.\\

\subsection{Arête}
Notre algorithme associe chaque sommet à un entier. Nous avons représenté les arêtes par des couples d'entier $(u, v)$ stocké dans des structures. Une arête $(u, v)$ relie le sommet $u$ au sommet $v$

\subsection{Tas min} %Pierre
L'algorithme Prim appliqué à un graphe $G = (S, A)$ doit trouver $|A|$ fois une arête de poids minimum dans un ensemble donné.
Nous avons donc eu besoin d'une structure de donnée qui permettre d'extraire le minimum d'un ensemble avec une faible complexité. Cette structure doit également supporter l'ajout et la suppression d'élément.
Nous avons choisi d’implémenter cette structure par un tas min.
Un tas min est un arbre ayant les propriétés suivantes :
\begin{itemize}
\item C'est un arbre binaire.
\item Le poids d'un nœud est inférieur à celui de chacun de ses fils. L'élément de poids minimum est donc celui représenté par la racine de l'arbre
\end{itemize}
Le poids d'un nœud est celui de l'élément qu'il décrit.
Chaque élément de l'ensemble a représenter est représenté par un nœud de l'arbre.

Dans le projet, les éléments de l'ensemble sont des arêtes, et leur poids est celui de l’arête dans le graphe. La taille du tas min est donc majoré par le nombre d’arêtes dans le graphe.
Nous avons implémenté le tas min dans une structure \textsf{Tas} contenant :
\begin{itemize}
\item Un tableau d’arêtes
\item Une Matrice
\item La taille maximum de l'ensemble que peut représenté l'arbre
\item Le nombre d'élément stoker dans l'arbre.
\end{itemize}
Le tableau permet de représenté l'arbre du tas min. Il est indexé en partant de 1.
L'indice 1 représente la racine l'arbre (ie l’arête de poids minimum de l'ensemble).
Soit $i$ l'indexe d'un nœud. Ses deux fils (s'ils existent) sont dans les cases d'index $2i$ et $2i +1$.

Toutes les arêtes qui seront stoker dans le \texttt{Tas} proviendront de la Matrice. Avoir accès à celle ci permet au \texttt{Tas} d'accéder aux poids des arêtes.

\section{Définition} %Pierre
Afin de démontrer que l’algorithme que nous avons utilisé retourne une solution dont la longueur n'excède pas deux fois la longueur d'une solution optimal, nous devons introduire un formalisme pour décrire le problème.
\begin{description}
 \item[Graphe non orienté] : Un graph $G$ est une paire $G = (S, A)$ où : 
 \begin{itemize}
 \renewcommand{\FrenchLabelItem}{\textbullet}
  \item S est un ensemble de sommets
  \item A un ensemble d'arêtes qui sont des paire de sommets. Chaque arête relie deux sommet et est pondérée par un poids.
 \end{itemize}
 \item[Chemin] : un chemin est une suite de sommets $x_1, x_2, \ldots, x_n$ tel que $\left(x_i, x_{i+1}\right) \in A$
 \item[Graphe connexe] : un graph $G$ est connexe si pour toutes paires de sommets $u, v \in G$, il existe un chemin reliant de $u$ à $v$.
 \item[Cycle] : un cycle est un chemin dont tous les sommets sont distincts, sauf les extrémités qui sont égales.
 \item[Cycle hamiltonien] : un cycle hamiltonien est un cycle qui parcourt l'ensemble des sommets du graph.
 \item[Arbre] : Un arbre est un un graph connexe sans cycle
 \item[Arbre binaire] : Un arbre est binaire si chacun de ses nœuds à au plus deux fils.
 \item[Profondeur d'un nœud] : on peut définir un sommet $r$ comme étant la racine de l'arbre. La profondeur d'un élément $s$ dans un arbre est alors le nombre de nœuds qui compose le compose le chemin entre $r$ et $u$.
 \item[Arbre couvrant] : Un arbre $T$ est couvrant sur un graph $G$ si tous les sommets de $G$ sont dans $T$.
 \item[Arbre couvrant minimum] : Un arbre couvrant est minimum s'il minimise la somme des poids des arêtes qui le compose.
\end{description}

\section{Algorithmes}


L'algorithme que nous avons implémenté pour résoudre le problème du voyageur de commerce est composé de deux fonctions principales, la fonction Prim et une fonction pour parcourir l'arbre couvrant.\\

\subsection{Prim} %Alice

L'algorithme Prim permet de construire un arbre couvrant minimal à partir d'un graphe. Il prend en entrée une \textsf{Matrice} dont \texttt{arbre\_couvrant} est vide (c'est à dire que le vecteur contient initialement que des listes vides : aucun sommet n'a de voisin). Il la modifie afin que \texttt{arbre\_couvrant} représente un arbre couvrant minimal du graphe.\\

\subsubsection*{Algo}
\begin{description}
\item[Entrée] : Une Matrice \texttt{M} telle que \texttt{M->arbre\_couvrant} ne contient que des listes vides et \texttt{M->marque} ne contient que des zéros (aucun sommet n'est encore marqué, les sommets marqués sont ceux qui appartiennent à l'arbre couvrant). \texttt{M} doit représenter un graph complet dont le poids des arêtes respecte l'inégalité triangulaire.
\item[Sortie] : La Matrice \texttt{M} modifiée telle que \texttt{M->marque} ne contient que des 1, c'est à dire que l'arbre couvrant contient tous les sommets. Cet arbre couvrant est minimal.
\end{description}


\textit{Algorithme : } \\
Prim initialise un tas min $T$ qui contiendra des arêtes. \textcolor{red}{Calcule exacte ?} On peut avoir jusqu'à $n^2/2$ arêtes dans le tas min, ce qui sera la capacité de $T$. Le tas min contiendra l'ensemble des arêtes du graph incidente à au moins un sommet de l'arbre couvrant en cour de construction.\\
Prim ajoute le sommet 0 à l'arbre (le choix du sommet 0 est arbitraire, on pourrait prendre n'importe lequel).\\
Prim ajoute a $T$ toutes les arêtes du graphe partant de zéro.\\
\\
Tant que toutes les arêtes ne sont pas marquées : 
Prim extrait l'arête de poids minimum de $T$ jusqu'à obtenir une arête dont un seul des deux sommets est marqué (c'est fait par la fonction \texttt{trouver\_bonne\_arete} : elle vérifie qu'au moins une des extrémités n'est pas déjà marqué. Puisque les seul aretes qui sont ajouté à $T$ sont celles qui ont un sommet marqué, on est assuré que l'arête réponde au critère).\\
Prim ajoute cette arête et le sommet non marqué à l'arbre.\\
Puis Prim marque ce sommet et Prim ajoute à $T$ les arêtes partant du dernier sommet ajouté à l'arbre.\\
\\
A la fin de cette boucle, tous les sommets ont été marqué et la \texttt{M->arbre\_couvrant} contient un arbre couvrant de poids minimal.\\

\subsubsection*{Complexité}

\subsection{Parcourt de l'arbre} %Alice
\subsubsection*{Algo}
\begin{description}
\item[Entrée] : 
\item[Sortie] : 
\end{description}
\subsubsection*{Complexité}

\subsection{Primitives tas min} %Pierre
La structure \texttt{Tas} suporte 3 primitives :
\begin{itemize}
\item \texttt{extraire\_min} : permet de supprimer et renvoyer l’élément de poids minimum du tas.
\item \texttt{acutalise\_tas} : utilisé uniquement par \texttt{extraire\_min}, cette primitive permet de restaurer les propriétés d'un tas min après la suppressions d'un élément.
\item \texttt{entasser\_element} : permet d'ajouter un élément au tas.
\end{itemize}
\subsubsection*{extraire\_min}
\begin{description}
\item[Entrée] : un \textsf{Tas} $T$ non vide ayant les propriété du tas min
\item[Sortie] : un élément $a \in T$ de poids minimum. l'élément de $a$ à été supprimé de $T$, et $T$  les propriété d'un tas min.
\end{description}
\paragraph*{Algo}
\paragraph*{Complexité}

\subsubsection*{acutalise\_tas}
\begin{description}
\item[Entrée] : 
\item[Sortie] : 
\end{description}
\paragraph*{Algo}
\paragraph*{Complexité}

\subsubsection*{acutalise\_tas}
\begin{description}
\item[Entrée] : 
\item[Sortie] : 
\end{description}
\paragraph*{Algo}
\paragraph*{Complexité}


\section{Preuve de 2-approximation} %Pierre
Bien que le problème du voyageur de commerce soit un problème NP-Complet, il existe une solution pour approximer si on suppose inégalité triangulaire pour le poids des arêtes. L'algorithme que nous avons utilisé est une 2-approximation : la solution retournée par l'algorithme n'exede pas deux fois la longueur d'une solution optimal.

Le poids d'un graph/arbre/cycle est la somme des poids des arêtes qui le compose.
Dans cette section, nous interchangeables les termes poids et de distance, car dans notre problème, le poids d'une arête $(u,v)$ $(u,v)$ représente la distance séparant les sommets $u$ et $v$.

Le poids d'une solution optimal $c(Opt)$ est borné par le poids d'un arbre couvrant minimum $c(T)$ :
En supprimant une arête de $Opt$, on obtient un arbre couvrant car $Opt$ est un cycle hamiltonien. Par minimalité de $T$, on a donc \begin{equation}
c(T) < c(Opt)
\label{eq1}
\end{equation}

\begin{figure}[!h]
\centering
\begin{tikzpicture}[scale=1, auto,swap]
    % sommet
    \foreach \pos/\name in {{(-1,5)/a}, {(1,3)/b}, {(1,4)/c},{(1,5)/d}, {(2,4)/e}, {(2,2)/f}, {(3,1)/g}, {(4,2)/h}, {(3,3)/i}, {(3,0)/j}, {(1,1)/k}}
        \node[vertex] (\name) at \pos {$\name$};
    % arete
    \foreach \source/ \dest in {a/d, d/e, e/i, i/h, h/g, g/j, j/k, k/f, f/b, b/c, c/a}
        \path[cycle] (\source) -- (\dest);
    \foreach \source/ \dest in {d/e, e/i, i/h, h/g, g/j, j/k, k/f, f/b, b/c, c/a}
        \path[edge] (\source) -- (\dest);
\end{tikzpicture}
\caption{Une solution optimal en gris et un arbre couvrant en noir}
\end{figure}


Soit $C$ le chemin définit comme suit :
Choisir $s \in T$ in sommet. En partant de $s$, longer les arêtes de $T$ jusqu’à revenir au sommet $s$. Chaque arête de $T$ sera longer deux fois (une fois par côté de l'arête).

\begin{figure}[!h]
\centering
\begin{tikzpicture}[scale=1, auto,swap]
    % sommet
    \foreach \pos/\name in {{(-1,5)/a}, {(1,3)/b}, {(1,4)/c},{(1,5)/d}, {(2,4)/e}, {(2,2)/f}, {(3,1)/g}, {(4,2)/h}, {(3,3)/i}, {(3,0)/j}, {(1,1)/k}}
        \node[vertex] (\name) at \pos {$\name$};
    % arete
    \foreach \source/ \dest in {a/b, b/c, c/d, c/e, b/f, f/k, f/g, g/j, g/h, h/i}
        \path[edge] (\source) -- (\dest);
    \draw[cheminarbre] (a.south west) \foreach \dest in {b.south west, f.west, k.north west, k.west, k.south west, k.south, k.south east, f.south, g.south west, j.west, j.south west, j.south, j.south east, j.east, g.east, h.south east, h.east, h.north east, i.north east, i.north, i.north west, i.west, i.south west, h.west, g.north, f.north east, b.north east,  c.south east, e.south, e.south east, e.east, e.north east, e.north, c.north east, d.east, d.north east, d.north, d.north west, d.west, c.west, a.north east}{ -- (\dest)};
\end{tikzpicture}
\caption{Arbre couvrant minimum $T$ en noire et chemin $C$ en bleu}
\end{figure}

\begin{equation}
c(C) = 2c(T)
\label{eq2}
\end{equation}
En combinant (\ref{eq1}) et (\ref{eq2}), on obtient
\begin{equation}
c(C) < 2c(Opt)
\label{eq2}
\end{equation}

Le chemin $C$ n'est pas une solution au problème du voyageur de commerce car des sommets sont parcouru plusieurs fois dans $C$. Cependant, grâce à l'inégalité triangulaire, supprimer un sommet de $C$ n’augmente pas le cout de $C$.
Pour obtenir un cycle à partir de $C = x_1, x_2, \ldots, x_n, x_1$ : 
pour chaque sommet $x_i \in C, i\neq1$, conserver uniquement sa première occurrence.

\begin{figure}[!h]
\centering
\begin{tikzpicture}[scale=1, auto,swap]
    % sommet
    \foreach \pos/\name in {{(-1,5)/a}, {(1,3)/b}, {(1,4)/c},{(1,5)/d}, {(2,4)/e}, {(2,2)/f}, {(3,1)/g}, {(4,2)/h}, {(3,3)/i}, {(3,0)/j}, {(1,1)/k}}
        \node[vertex] (\name) at \pos {$\name$};
    % arete
        \foreach \source/ \dest in {a/b, b/f, f/k, k/g, g/j, j/h, h/i, i/c, c/e, e/d, d/a}
        \path[edge] (\source) -- (\dest);
\end{tikzpicture}
\caption{Chemin $W$ en noir}
\end{figure}

\section{Graphique} %Pierre

\section{Utilisation du programme} %Alice

\section{Conclusion} %Alice


\section{Références}

\end{document}


